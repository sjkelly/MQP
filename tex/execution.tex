\chapter{Implementation}

\section{Simplex}

We began by implementing a Simplex type, defined as follows:

\begin{lstlisting}
"""
A `Simplex` is a generalization of an N-dimensional tetrahedra and can be thought
of as a minimal convex set containing the specified points.

* A 0-simplex is a point.
* A 1-simplex is a line segment.
* A 2-simplex is a triangle.
* A 3-simplex is a tetrahedron.

Note that this datatype is offset by one compared to the traditional
mathematical terminology. So a one-simplex is represented as `Simplex{2,T}`.
This is for a simpler implementation.

It applies to infinite dimensions. The sturucture of this type is designed
to allow embedding in higher-order spaces by parameterizing on `T`.
"""
immutable Simplex{N,T} <: AbstractSimplex{N,T}
    _::NTuple{N,T}
end
\end{lstlisting}

With the definition in GeometryTypes, we afford ourselves two notions of
dimensionality. Our first parameter `N` gives us the total dimensionality
of the simplex. `T` is the type of the points. For example in Julia we can
prefix a colon to an identifier and make it a symbol which is reflected
in the type information:

\begin{lstlisting}
julia> using GeometryTypes

julia> Simplex(:x,:y,:z)
GeometryTypes.Simplex{3,Symbol}((:x,:y,:z))
\end{lstlisting}

Symbolic representation will allow us to create parametric geometry.
Likewise we can construct concrete types:

\begin{lstlisting}
julia> Simplex(Point(0,0,0), Point(1,1,1))
GeometryTypes.Simplex{2,FixedSizeArrays.Point{3,Int64}}((FixedSizeArrays.Point{3,Int64}((0,0,0)),FixedSizeArrays.Point{3,Int64}((1,1,1))))
\end{lstlisting}

This last example illustrates how this type can give us extra generalization.
Here we have constructed a line segment in 3D space. The Simplex is of
size two but the space it occupies is three dimensional. This way it acts
similar to a fixed size vector, but the type implies all points are on the
convex hull. (Should update decription to be accurate here).

Below is an example of a high performance implementation of Simplex decomosition:

\begin{lstlisting}
"""
Decompose an N-Simplex into tuple of Simplex{2}
"""
@generated function decompose{N, T1, T2}(::Type{Simplex{2, T1}},
                                       f::Simplex{N, T2})
    # other wise degenerate
    2 <= N || error("decompose not implented for N <= 2 yet. N: $N")

    v = Expr(:tuple)
    append!(v.args, [:(Simplex{2,$T1}(f[$(i)],
                                        f[$(i+1)])) for i = 1:N-1])
    # connect vertices N and 1
    push!(v.args, :(Simplex{2,$T1}(f[$(N)],
                                     f[$(1)])))
    v
end
\end{lstlisting}




To some extent, much of the basic defintions have been implemented
in libraries such as CGAL, Boost, and ShapeOP. However these libraries
are written in C and C++, compiled langauges, that are not amicable to dynamic
exploration. Our system should allow us to quickly prototype tests and
visualize relationships. This is something that Julia provides extremely well.
Primarily it accomplishes this through optional type annotations and
multiple dispatch. Secondarily, it has a rich history of integration with
interactive computing environments such as a REPL, Jupyter, and Juno.


Prior to this project, GeometryTypes primarily provides for Polygonal Mesh
type that is well tuned for operations on the CPU and GPU. It is defined
as follows:

\begin{lstlisting}
"""
The `HomogenousMesh` type describes a polygonal mesh that is useful for
computation on the CPU or on the GPU.
All vectors must have the same length or must be empty, besides the face vector
Type can be void or a value, this way we can create many combinations from this
one mesh type.
This is not perfect, but helps to reduce a type explosion (imagine defining
every attribute combination as a new type).
"""
immutable HomogenousMesh{VertT, FaceT, NormalT, TexCoordT, ColorT, AttribT, AttribIDT} <: AbstractMesh{VertT, FaceT}
    vertices            ::Vector{VertT}
    faces               ::Vector{FaceT}
    normals             ::Vector{NormalT}
    texturecoordinates  ::Vector{TexCoordT}
    color               ::ColorT
    attributes          ::AttribT
    attribute_id        ::Vector{AttribIDT}
end
\end{lstlisting}

The first thing to note is the provisions for attributes, colors, and textures.
These are used for mapping textures and/or colors to polygons via APIs such as
OpenGL. We do not need these (at least yet) in a rigourous mathematical
definition. Likewise, in a HomogenousMesh we structure the realization as
follows: 1. Insert all vertices of the mesh into `vertices` 2. Construct
Faces of at least 3 indices referencing the points in `vertices`.

This gives us certain properties that are nice for computation. Primarily
this allows us to observe the combinatorial properties of the mesh by analyizing
the faces. In addition, this compacts the data representation of vertices
since shared vertices can be represented with a common face index. Affine
transforms only need to operate on the vertices. Thus, in the optimistic versus
pessimistic case these operations can be 3x faster with this layout
assuming all vertices are in 3 faces.

Maybe a good idea to implement on this type too?

\section{Parametric Triangle}




\section{Signed Distance Field}


\section{Polytope}


\section{Combinatorial Operations}




