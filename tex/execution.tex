\chapter{Implementation}

In this section we will begin to outline the implementation of
various forms of parametric polytopes.

\section{Survey of Available Packages}

In chapter 3 we outlined the rationale for using Julia for mathematical
computer programming. An additional impetus was the familiarity of the
geometry packages. There will be various references to these and they
are outlines below.

\subsection{GeometryTypes.jl}

GeometryTypes.jl provides datatypes and basic operations for computational
geometry. This package began as a unification of types located in
HyperRectangles.jl, Meshes.jl, and GLAbstraction.jl. With the introduction
of this package the community made some initial progress on designing
types that can be used for computation on the CPU and GPU. Much of
our basic combinatorial analysis operations and data types have be contributed
to the package.

\subsection{FileIO.jl and MeshIO.jl}

FileIO.jl is a package that unifies various file loaders that existed in
the Julia package ecosystem under one import. The purpose is to
allow users to simply call the 'save' and 'load' functions with file
information inferred from file extensions, magic numbers, or data types.
MeshIO.jl is one such packge that provides file loaders for
polygonal mesh data. The file formats supported as of this writing include
obj, stl, ply, off, and 2dm.

\subsection{Meshing.jl}

Meshing.jl provides algorithims for converting signed distance field
data into polytopes. The two algorithms currently provided are
the Marching Cubes and Marching Tetrahedra algorithms.

\subsection{Meshes.jl}

Meshes.jl is currently a meta-package\footnote{Meta-package means
no code is contained in the package besides imports from others. It is
often used for stability purposes.} that imports elements on GeometryTypes.jl,
FileIO.jl, and Meshing.jl. It is one of the older packages in the
Julia package ecosystem and was an early center of collaboration before
the scopes began to expand. Older releases before Meshes.jl became a meta-package 
are maintained for insitutional users. The name space is held to
allow for a center for experimentation as stability in the base packages
becomes more neccesary.

\subsection{ParametricPolyhedra.jl}

ParametricPolyhedra.jl is a package used for solving constraints on
triangular faces of a polyhedra. The intention of this package
is to allow polyhedra to be specified via angles and edge lengths.


\section{Simplex Implementation}

We began by implementing a Simplex type in GeometryTypes.jl,
defined as follows:

\begin{lstlisting}
"""
A `Simplex` is a generalization of an N-dimensional tetrahedra and can be thought
of as a minimal convex set containing the specified points.

* A 0-simplex is a point.
* A 1-simplex is a line segment.
* A 2-simplex is a triangle.
* A 3-simplex is a tetrahedron.

Note that this datatype is offset by one compared to the traditional
mathematical terminology. So a one-simplex is represented as `Simplex{2,T}`.
This is for a simpler implementation.

It applies to infinite dimensions. The sturucture of this type is designed
to allow embedding in higher-order spaces by parameterizing on `T`.
"""
immutable Simplex{N,T} <: AbstractSimplex{N,T}
    _::NTuple{N,T}
end
\end{lstlisting}

With the definition in GeometryTypes, we afford ourselves two notions of
dimensionality. Our first parameter \texttt{N} gives us the total dimensionality
of the simplex. `T` is the type of the points. For example in Julia we can
prefix a colon to an identifier and make it a symbol which is reflected
in the type information:

\begin{lstlisting}
julia> using GeometryTypes

julia> Simplex(:x,:y,:z)
GeometryTypes.Simplex{3,Symbol}((:x,:y,:z))
\end{lstlisting}

Symbolic representation will allow us to create parametric geometry.
Likewise we can construct concrete types:

\begin{lstlisting}
julia> Simplex(Point(0,0,0), Point(1,1,1))
GeometryTypes.Simplex{2,FixedSizeArrays.Point{3,Int64}}((FixedSizeArrays.Point{3,Int64}((0,0,0)),FixedSizeArrays.Point{3,Int64}((1,1,1))))
\end{lstlisting}

This last example illustrates how this type can give us extra generalization.
Here we have constructed a line segment in 3D space. The Simplex is of
size two but the space it occupies is three dimensional. This way it acts
similar to a fixed size vector, but the type implies all points are on the
convex hull. (Should update decription to be accurate here).

Below is an example of a high performance implementation of Simplex decomosition:

\begin{lstlisting}
"""
Decompose an N-Simplex into tuple of Simplex{2}
"""
@generated function decompose{N, T1, T2}(::Type{Simplex{2, T1}},
                                       f::Simplex{N, T2})
    # other wise degenerate
    2 <= N || error("decompose not implented for N <= 2 yet. N: $N")

    v = Expr(:tuple)
    append!(v.args, [:(Simplex{2,$T1}(f[$(i)],
                                        f[$(i+1)])) for i = 1:N-1])
    # connect vertices N and 1
    push!(v.args, :(Simplex{2,$T1}(f[$(N)],
                                     f[$(1)])))
    v
end
\end{lstlisting}

\section{Issues with Existing Polyhedral Mesh Types}

Prior to this project, GeometryTypes primarily provides for Polygonal Mesh
type that is well tuned for operations on the CPU and GPU. It is defined
as follows:

\begin{lstlisting}
"""
The `HomogenousMesh` type describes a polygonal mesh that is useful for
computation on the CPU or on the GPU.
All vectors must have the same length or must be empty, besides the face vector
Type can be void or a value, this way we can create many combinations from this
one mesh type.
This is not perfect, but helps to reduce a type explosion (imagine defining
every attribute combination as a new type).
"""
immutable HomogenousMesh{VertT, FaceT, NormalT, TexCoordT, ColorT, AttribT, AttribIDT} <: AbstractMesh{VertT, FaceT}
    vertices            ::Vector{VertT}
    faces               ::Vector{FaceT}
    normals             ::Vector{NormalT}
    texturecoordinates  ::Vector{TexCoordT}
    color               ::ColorT
    attributes          ::AttribT
    attribute_id        ::Vector{AttribIDT}
end
\end{lstlisting}

The first thing to note is the provisions for attributes, colors, and textures.
These are used for mapping textures and/or colors to polygons via APIs such as
OpenGL. We do not need these (at least yet) in a rigourous mathematical
definition. Likewise, in a HomogenousMesh we structure the realization as
follows: 1. Insert all vertices of the mesh into `vertices` 2. Construct
Faces of at least 3 indices referencing the points in `vertices`.

This gives us certain properties that are nice for computation. Primarily
this allows us to observe the combinatorial properties of the mesh by analyizing
the faces. In addition, this compacts the data representation of vertices
since shared vertices can be represented with a common face index. Affine
transforms only need to operate on the vertices. Thus, in the optimistic versus
pessimistic case these operations can be 3x faster with this layout
assuming all vertices are in 3 faces.



\section{Parametric Triangle}




\section{Signed Distance Field}

\subsection{Signed Distance Fields}

\todo{rewrite to be salient}

A signed distance field (SDF) is a uniform sampling of an implicit function,
or any oriented geometry. \todo{didn't introduce orientation, winding order, etc...}
Below
we can see this in action over the definition of a circle.

\begin{lstlisting}
julia> f(x,y) = sqrt(x^2+y^2) - 1
f (generic function with 1 method)

julia> v = Array{Float64,2}(5,5) # construct a 2D 5x5 array of Float64

julia> for x = 0:4, y = 0:4
           v[x+1,y+1] = f(x,y)
       end

julia> v
5x5 Array{Float64,2}:
 -1.0  0.0       1.0      2.0      3.0    
  0.0  0.414214  1.23607  2.16228  3.12311
  1.0  1.23607   1.82843  2.60555  3.47214
  2.0  2.16228   2.60555  3.24264  4.0    
  3.0  3.12311   3.47214  4.0      4.65685
\end{lstlisting}

The results of \texttt{v} might be confusing since the matrix is oriented with
the origin in the top left corner. At coordinate $(0,0)$, or entry \texttt{v[1,1]},
we see that \texttt{f} is
equal to \texttt{-1}. Likewise we can see $(0,1)$ and $(1,0)$ are points on
the boundary since the value is \texttt{0} and everywhere else is positive.

Distance fields are interesting since they provide an intermediate representation
between functional space and discrete-geometric space. However they are
a very memory hungry data structure. Pixar has published OpenVDB which helps
work around these concerns, but such compression can be lossy.\cite{OpenVDB}
With the advent of shader pipelines for GPUs, distance fields have become
more popular. Valve has used SDFs with great success for generating smooth
text.text renders. \cite{Green_2007}
Many algorithms for generating polyhedra from an SDF
exist. The most common are Marching Tetrahedra, Marching Cubes,
and Dual Contours.\cite{Muller_Wehle_1997}\cite{Newman_Yi_2006}\cite{Cook_Hourvitz}

\todo{Talk about vert and frag shaders.}

Andreas Bærentzen and Henrik Aanæs published methods on the inverse
problem of converting a mesh to a signed distance fields.\cite{Baerentzen_Aanaes}
DiFi was introduced in 2004, which demonstrates an algorithm for creating
SDFs on multiple types of geometry \cite{Sud_Otaduy_Manocha_2004}.
\todo{Need to re-read this paper}

Many necessary algorithms in path planning for digital manufacturing tools
fall out of distance fields. For example, offsetting simply becomes
an addition or subtraction over the SDF. Computing the medial axis becomes
a scan for inflection points. Many path planners need to simplify polygon
representations as to not generate move less than the resolution of the machine.
Assuming the machine uses a Cartesian system, a SDF can correspond perfectly
to the lowest available resolution of the machine.
Likewise as Stereolithographic 3D printers
begin to use digital mirror devices (commonly known as DLP or DMD)
, discrete representations of geometry will become more important in
digital manufacturing.

\cite{Pasko_Adzhiev_Comninos_2008}


\section{Polytope}


\section{Combinatorial Operations}




